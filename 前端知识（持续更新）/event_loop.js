/*
 * @Author: 子非鱼
 * @Description: 文件描述~
 * @Date: 2021-03-03 11:11:37
 * @LastEditTime: 2021-03-03 15:13:05
 * @LastEditors: Do not edit
 * @FilePath: /前端知识（持续更新）/event_loop.js
 */

//  事件循环
/** 
 * 
 * 1. JavaScript是单线程，非阻塞的
 * 
 * 非阻塞：通过 event loop 实现。
 *
 * 
 * 2. 浏览器的事件循环
 * 
 * 
 *  事件队列: 异步代码的执行，遇到异步事件不会等待它返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。
 *  当异步事件返回结果，将它放到事件队列中，被放入事件队列不会立刻执行起回调，而是等待当前执行栈中所有任务都执行完毕，
 *  主线程空闲状态，主线程会去查找事件队列中是否有任务，
 *  如果有，则取出排在第一位的事件，并把这个事件对应的回调放到执行栈中，然后执行其中的同步代码。
 * 
 * 
 * 宏任务和微任务
 * 
 * 为什么要引入微任务，只有一种类型的任务不行么？
 * 
 * 页面渲染事件，各种I/O的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，
 * 我们不能准确地控制这些事件被添加到任务队列中的位置。
 * 但是这个时候突然有高优先级的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了微任务队列。
 * 
 * 
 * 不同的异步任务被分为：宏任务和微任务
 * 
 * 宏任务：
 * 
 *   script(整体代码)
 *   setTimeout()
 *   setInterval()
 *   postMessage
 *   I/O（磁盘读取，网络交互）
 *   UI交互事件
 * 
 * 微任务:
 * 
 *    new Promise().then(回调)
 *    MutationObserver(html5 新特性)
 * 
 * 异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。
 *
 * 当前执行栈执行完毕后时会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。
 * 
 * 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：
 *
 *  执行一个宏任务（栈中没有就从事件队列中获取）
 *  执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
 *  宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
 *  当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
 *  渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
 *
 * 
 * * 
*/