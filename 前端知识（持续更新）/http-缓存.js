/*
 * @Author: 子非鱼
 * @Description: 文件描述~
 * @Date: 2021-03-02 14:42:56
 * @LastEditTime: 2021-03-02 19:32:03
 * @LastEditors: Do not edit
 * @FilePath: /前端知识（持续更新）/http-缓存.js
 */

//  web缓存

/**
 * 
 *  前端缓存 和 后端缓存
 * 
 * 基本的网络请求就是三个步骤：请求，处理，响应。
 * 
 * 后端缓存主要集中于“处理”步骤，通过保留数据库连接，存储处理结果等方式缩短处理时间，尽快进入“响应”步骤。
 * 
 * 而前端缓存则可以在剩下的两步：“请求”和“响应”中进行。
 * 
 * 在“请求”步骤中，浏览器也可以通过存储结果的方式直接使用资源，直接省去了发送请求；
 * 
 * 而“响应”步骤需要浏览器和服务器共同配合，通过减少响应内容来缩短传输时间】
 * 
 * 
 * 按缓存位置分类
 * 
 *  Service Worker 
 *  Memory Cache
 *  Disk Cache
 *  网络请求
 *  
 *  它们的查找优先级是：(由上到下寻找，找到即返回；找不到则继续)
 * 
 * 
 *  memory cache 是内存中的缓存
 * 
 * 几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。
 * 但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 注定只能是个“短期存储”。
 * 常规情况下，浏览器的 TAB 关闭后该次浏览的 memory cache 便告失效。
 * 
 * memory cache 主要存储预加载的资源。
 * 
 * memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 <img>，两个 href 相同的 <link>) 都实际只会被请求最多一次，避免浪费。
 * 
 * 在从 memory cache 获取缓存内容时，浏览器会忽视例如 max-age=0, no-cache 等头部配置。
 * 例如页面上存在几个相同 src 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。
 * 这是因为 memory cache 只是短期使用，大部分情况生命周期只有一次浏览而已。
 * 而 max-age=0 在语义上普遍被解读为“不要在下次浏览时使用”，所以和 memory cache 并不冲突。
 * 
 * 但如果不想让一个资源进入缓存，就连短期也不行，那就需要使用 no-store。
 * 存在这个头部配置的话，即便是 memory cache 也不会存储，自然也不会从中读取了。
 * 
 * 
 * 
 * 
 * disk cache 磁盘缓存
 * 
 * disk cache 也叫 HTTP cache，顾名思义是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。
 * 而且它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。
 * 
 * disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。
 * 当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。
 * 绝大部分的缓存都来自 disk cache。
 * 
 * 
 * 
 * Service Worker
 * 
 * 上述的缓存策略以及缓存/读取/失效的动作都是由浏览器内部判断 & 进行的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。
 * 但 Service Worker 的出现，给予了我们另外一种更加灵活，更加直接的操作方式。
 * 
 * 
 * Service Worker 这个缓存是永久性的，即关闭 TAB 或者浏览器，下次打开依然还在。
 * 有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。
 * 
 * 如果 Service Worker 没能命中缓存，一般情况会使用 fetch() 方法继续获取资源。
 * 这时候，浏览器就去 memory cache 或者 disk cache 进行下一次找缓存的工作了。
 * 注意：经过 Service Worker 的 fetch() 方法获取的资源，即便它并没有命中 Service Worker 缓存，甚至实际走了网络请求，也会标注为 from ServiceWorker。
 * 
 * 
 * 请求网络
 * 
 * 如果一个请求在上述 3 个位置都没有找到缓存，那么浏览器会正式发送网络请求去获取内容。
 * 之后容易想到，为了提升之后请求的缓存命中率，自然要把这个资源添加到缓存中去。具体来说：
 * 
 *   1.根据 Service Worker 中的 handler 决定是否存入 Cache Storage (额外的缓存位置)。
 *   2.根据 HTTP 头部的相关字段(Cache-control, Pragma 等)决定是否存入 disk cache
 *   3.memory cache 保存一份资源的引用，以备下次使用。
 * 
 * 
 * 
 * 按失效策略分类
 * 
 * 1. memory cache 是浏览器为了加快读取缓存速度而进行的自身的优化行为，不受开发者控制，也不受 HTTP 协议头的约束
 * 2. Service Worker 是由开发者编写的额外的脚本，且缓存位置独立，出现也较晚，使用还不算太广泛
 * 3.  disk cache，也叫 HTTP cache (因为不像 memory cache，它遵守 HTTP 协议头中的字段)。平时所说的强制缓存，对比缓存，以及 Cache-Control 等，也都归于此类。
 * 
 * 
 * 
 * 强制缓存 (也叫强缓存)
 * 
 * 强制缓存的含义是，当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库。
 * 
 * 强制缓存直接减少请求数，是提升最大的缓存策略。 它的优化覆盖了文章开头提到过的请求数据的全部三个步骤。如果考虑使用缓存来优化网页性能的话，强制缓存应该是首先被考虑的。
 *
 * 可以造成强制缓存的字段是 Cache-control 和 Expires。
 * 
 * Expires
 * 这是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)，如
 * Expires: Thu, 10 Nov 2017 08:45:11 GMT
 * 
 * 
 * Cache-control
 * 
 * 已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control。
 * 该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。
 * 这两者的区别就是前者是绝对时间，而后者是相对时间。如
 * Cache-control: max-age=2592000
 * 
 * 下面列举一些 Cache-control 字段常用的值：(完整的列表可以查看 MDN)

    max-age：即最大有效时间，在上面的例子中我们可以看到
    must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
    no-cache：虽然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。
    no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。
    public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
    private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。
 * 
 * 
 * Cache-control 的优先级高于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段我们都会设置。
 * 
 * 
 * 对比缓存 (也叫协商缓存)
 * 
 * 当强制缓存失效(超过规定时间)时，就需要使用对比缓存，由服务器决定缓存内容是否失效。
 * 
 * 流程上说，浏览器先请求缓存数据库，返回一个缓存标识。
 * 之后浏览器拿这个标识和服务器通讯:
 * 如果缓存未失效，则返回 HTTP 状态码 304 表示继续使用，于是客户端继续使用缓存；
 * 如果失效，则返回新的数据和缓存规则，浏览器响应数据后，再把规则写入到缓存数据库。
 * 
 * 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，
 * 因此 在响应体体积上的节省是它的优化点。
 * 
 * 
 * 缓存小结
 * 
 * 1. 调用 Service Worker 的 fetch 事件响应
 * 2. 查看 memory cache
 * 3. 查看 disk cache。这里又细分：
    如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200
    如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200
 *
 * 4. 发送网络请求，等待网络响应
 * 5. 把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)
 * 6. 把响应内容 的引用 存入 memory cache (无视 HTTP 头信息的配置)
 * 7. 把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())
 * 
 * 
 * 浏览器的行为

 * 所谓浏览器的行为，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：

    1.打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
    2.普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
    3.强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache)。服务器直接返回 200 和最新内容。
 * 
 * 
 * 
 * 
 * */ 